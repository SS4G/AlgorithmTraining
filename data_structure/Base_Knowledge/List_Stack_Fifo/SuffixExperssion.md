## 关于后缀表达式
后缀表达式的计算方法是
遇到一个值就将这个值压入堆栈
遇到一个运算符就将两个值弹出 计算结果后在压入堆栈 从左向右进行扫描

12+34+*
的结果就是 
(1+2)*(3+4) = 21


一般人所阅读的的表达式都是中缀表达式
```
1+2*4+3*(4*5+3)
```
中缀表达式中默认 同一个括号级别中的 */ 运算符比 +-运算符的优先级高
加了括号的话 括号里面的运算符的优先级比括号外面的运算符的优先级要高。

这样经一部抽象就可以把括号去掉抽象为以下的形式。  
用Vi表示操作数i表示操作数的从左至右下标 用O(k)表示运算符。      
k是运算符在整体的表达式中的优先级 
所以举个例子：
```
1+2*4+3*(4*5+3) ->
# 只标明运算符优先级 运算符下面对应的 数字是优先级
1 + 2 * 4 + 3 * 4 * 5 + 3
  0   1   0   1   3   2
```

整个的表达式中 按照运算符优先级的从高到低 优先级最高的运算符两边的操作数  
被按照操作符所指示的操作结合成一个值作为新的操作数放在对应的位置。然后一  
步一步的结合 知道最后所有的操作符都消失此时只有一个数字作为结果

```
# step1
1 + 2 * 4 + 3 * 4 * 5 + 3
  0   1   0   1   3   2

# step2
1 + 2 * 4 + 3 * 20 + 3
  0   1   0   1    2
  
# step3
1 + 2 * 4 + 3 * 23
  0   1   0   1   
  
# step3
1 + 8 + 69
  0   0 
 
# step4
78
```

其实在计算表达式时 完全可以不必完全按照 元素安抚优先级从高到低的顺序来计算  
例如 :
```
# 对于运算符优先级单调递增的表达式 计算的过程是从后向前结合
a * b + c + d + e * c
  0   1   2   3   4    
# 对于运算符优先级不是单调递增的表达式 如果从前向后结合的话
# 可以将前面一段单调递增的部分先算出来 再算后面各段单调递增的
a * b + c + d + e * f + g + h + i + j
  0   1   2   3   4   0   1   2   3  
# 可以先计算出 a~e 将结果压入堆栈再计算出 g~j 将结果压入堆栈
# 然后在求这两部分的和

```
对于后缀表达式 若中缀表达式的运算符优先级是单调递增的
那么 
```
# midfix
a * b + c + d + e * c
  0   1   2   3   4 
# suffix
abcde*+++*
     43210
      
```
由上面可以看出 运算符左面优先级单调递增的表达式的 后缀表达式是操作数正序

例如：

```
1+2+3
 0 1
```
 
因为 后面的预案算符优先级更高 前面低优先级的运算要依赖后面高优先级的  
运算的结果 所以 可以将低优先级的运算符和他左边的操作数都压到栈里面到  
如果高优先级的运算符结合完了以后被输出到了输出流中 ,此时有了完整的有  
操作数 堆栈中的低优先级操作符才能够输出。  
将中缀表达式转换为后缀表达式的整个的这个过程有点类似于函数的嵌套调用  
，外部的函数只有等到内部函数返回了以后才可以返回 外部函数就是类似于低  
优先级的运算符，开始调用的地方相当于是将做操作数放入输出中,内部函数返  
回的结果相当于是高优先级运算符的结果。函数的返回相当于将低优先级运算符  
输出到输出中。  
整个的过程中  
```
{//0 begin
    {//1 begin
        此处不是最深的但是这个函数最先返回
    }//1 end
    {//1begin
        { //2begin
            // 最深的嵌套函数并不一定最先返回
        }//2 end
    }//1end
}//0 end
```
### 总结
归根结底`堆栈的使用都是包含 一个操作执行过程中需要的信息需要通过其他  
类似的操作来获得的情况 这就需要使用堆栈来保存当前的信息 等到内部过程  
结束后再从堆栈中弹出之前的执行信息  函数调用 后缀表达式的计算 以及中  
缀表达式到后缀表达式的转换都符合这个规律

